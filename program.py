import cv2
from cv2.typing import MatLike
import numpy as np
import matplotlib.pyplot as plt
import math
import os
import sys

MIN_CIRCLE_SIZE = 20
MAX_CIRCLE_SIZE = 45
MIN_SQUARE_SIZE = 20
MAX_SQUARE_SIZE = 37
CIRLCE_MIN_RATIO = 0.8
SQUARE_MIN_RATIO = 0.75

def between(num, num1, num2):
    if num1 >= num2: 
        return False
    return num >= num1 and num <= num2

def size_between(contour, min_size, max_size):
    (_,_,w,h) = cv2.boundingRect(contour)
    return between(w,min_size,max_size) and between(h,min_size,max_size)

def is_square(contour):
    peri = cv2.arcLength(contour,True)
    poly = cv2.approxPolyDP(contour,peri*0.04,True)
    (_,_,w,h) = cv2.boundingRect(contour)
    ratio = w*1.0/h
    return len(poly) == 4

def print_bounding_rect(rect):
    (x,y,w,h) = rect
    print(f"{x:.6f} {y:.6f} {w:.6f} {h:.6f}")

def check_is_filled(src, contour: MatLike, desired_ratio):
    (x,y,w,h) = cv2.boundingRect(contour)
    area = src[y:y+h, x:x+w]
    filled_ratio = cv2.countNonZero(area)*1.0 / (w*h)
    return filled_ratio > desired_ratio

def is_filled_squares(src, contour):
    return is_square(contour) and check_is_filled(src,contour,SQUARE_MIN_RATIO)

def check_pos(rect1, rect2):
    (x1,y1,_,_) = rect1
    (x2,y2,_,_) = rect2
    return (x1-x2) * (y2 - y1)

def split(labels):
    # Chia ra từng nhóm, ngăn cách bởi dãy ô vuông
    results = []
    prevLabel = labels[0][0]
    started = prevLabel == "square"
    curGroup = []
    for label in labels:
        curLabel = label[0]
        if(curLabel == "square" and prevLabel == "circle"):
            if not started:
                started = True
            else:
                results.append(curGroup)
                curGroup = []
        if started:
            curGroup.append(label)
        prevLabel = curLabel
    results.append(curGroup)
    return results

def print_split(split_set):
    for region in split_set:
        print("-------------")
        for label in region:
            print(label[0], end = " ")
            print_bounding_rect(label[1])

def sortLeftRight(labels):
    return sorted(labels, key=lambda x: x[1][0])

def sortTopDown(labels):
    return sorted(labels, key=lambda x: x[1][1])

def sortDownTop(labels):
    return sorted(labels, key=lambda x: x[1][1],reverse=True)

def normalize(rect, width, height):
    (x,y,w,h) = rect
    return (x/width,y/height,w/width,h/height)

def toYOLOv8(rect):
    (x,y,w,h) = rect
    return (x+w/2, y+h/2,w,h)

def distance_x(rect1,rect2):
    return abs(rect1[0] - rect2[0])

def poly_len(contour):
    peri = cv2.arcLength(contour,True)
    poly = cv2.approxPolyDP(contour,peri*0.05,True)
    return len(poly)

def filled_ratio_square(src,contour):
    (x,y,w,h) = cv2.boundingRect(contour)
    area = src[y:y+h, x:x+w]
    filled_ratio = cv2.countNonZero(area)*1.0 / (w*h)
    return filled_ratio

def check_is_filled_circle(src, contour, desired_ratio):
    (x,y,w,h) = cv2.boundingRect(contour)
    area = src[y:y+h, x:x+w]
    #((x,y),r) = cv2.minEnclosingCircle(contour)
    r = (w+h)/4 + 0.5
    total = cv2.countNonZero(area)
    filled_ratio = total / (r*r*3.14)

    return filled_ratio > desired_ratio and ((w*1.0/h) < 1.3 and (h*1.0/w)<1.3)
    #return filled_ratio > desired_ratio

# The following code was generated by AI, use with caution

def group_rectangles_by_lines(rect_array):
    """
    Groups rectangles into lines based on vertical overlap.
    
    Args:
        rect_array: List of tuples, each containing (string, (x, y, width, height))
    
    Returns:
        List of lists, where each sublist contains elements from the same line
    """
    if not rect_array:
        return []
    
    # Sort rectangles by y-coordinate
    sorted_rects = sorted(rect_array, key=lambda x: x[1][1])
    
    lines = []
    current_line = [sorted_rects[0]]
    
    def has_vertical_overlap(rect1, rect2, overlap_threshold=0.5):
        """Check if two rectangles overlap vertically."""
        _, (_, y1, _, h1) = rect1
        _, (_, y2, _, h2) = rect2
        
        # Calculate overlap
        y1_bottom = y1 + h1
        y2_bottom = y2 + h2
        
        overlap = min(y1_bottom, y2_bottom) - max(y1, y2)
        min_height = min(h1, h2)
        
        return overlap > (min_height * overlap_threshold)
    
    # Group rectangles into lines
    for rect in sorted_rects[1:]:
        # Check if current rectangle overlaps with any rectangle in current line
        overlaps = any(has_vertical_overlap(prev_rect, rect) 
                      for prev_rect in current_line)
        
        if overlaps:
            current_line.append(rect)
        else:
            # Sort current line by x-coordinate before adding to lines
            current_line.sort(key=lambda x: x[1][0])
            lines.append(current_line)
            current_line = [rect]
    
    # Add the last line
    if current_line:
        current_line.sort(key=lambda x: x[1][0])
        lines.append(current_line)
    
    return lines

# end of AI-generated code snippet


def removeSingleSquares(square_labels):
    # Lọc các hình vuông đứng riêng rẽ, để lại đúng 27 hình vuông
    topdown_squares_check = [2,2,4,5,9,5]
    lines = group_rectangles_by_lines(square_labels)
    single_filtered = []
    result = []
    removed = []
    for line in lines:
        if(len(line) > 1):
            single_filtered.append(line)
        else:
            removed += line
    current_line = 0
    for line in single_filtered:
        if(len(line) == topdown_squares_check[current_line]):
            result += line
            current_line += 1
        else:
            removed += line
    return (result, removed)




    #lines = group_rectangles_by_lines(square_labels)
    #result = []
    #removed = []
    #for line in lines:
    #    if(len(line) > 1):
    #        result += line
    #    else:
    #        removed += line
    #return (result, removed)






def preprocess(img):
    # Tiền xử lí
    phieu_tno = cv2.imread(img)
    (img_h,img_w,_) = phieu_tno.shape
    phieu_tno = cv2.cvtColor(phieu_tno, cv2.COLOR_BGR2RGB)
    phieu_tno_gray = cv2.cvtColor(phieu_tno, cv2.COLOR_RGB2GRAY)
    blur = cv2.medianBlur(phieu_tno_gray,5)
    sharpen_kernel = np.array([[-1,-1,-1],[-1,9,-1],[-1,-1,-1]])
    sharpen = cv2.filter2D(blur,-1,sharpen_kernel)

    thresh = cv2.threshold(sharpen,235,255,cv2.THRESH_BINARY_INV)[1]
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2,2))
    close = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=2)
    return (thresh,close)

def findContours(img):
    # Tìm ra các ô vuông, tròn
    (thresh,close) = preprocess(img)

    cnts, _ = cv2.findContours(thresh, cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)

    #square = list(filter(is_square,cnts))

    needed = [x for x in cnts if size_between(x, MIN_CIRCLE_SIZE, MAX_CIRCLE_SIZE)]
    #squares = [x for x in needed if is_filled_squares(thresh,x)] 
    #circles = [x for x in needed if check_is_filled(close, x, CIRLCE_MIN_RATIO) and not is_filled_squares(close,x)]


    detected = []
    squares_labeled = []
    circles_labeled = []
    for x in needed:
        if is_filled_squares(thresh,x) or filled_ratio_square(thresh,x) >= 0.9 and size_between(x,MIN_SQUARE_SIZE,MAX_SQUARE_SIZE):
            labeled = ("square",cv2.boundingRect(x))
            detected.append(labeled)
            squares_labeled.append(labeled)
        elif check_is_filled_circle(close,x,CIRLCE_MIN_RATIO):
            labeled = ("circle",cv2.boundingRect(x))
            detected.append(labeled)
            circles_labeled.append(labeled)
    
    if len(squares_labeled) > 27:
        (squares_labeled, removed_squares) = removeSingleSquares(squares_labeled)
        detected = circles_labeled + squares_labeled
        # Các ô vuông thừa sẽ được coi là ô tròn để xử lí tiếp
        for removed_square in removed_squares:
            detected.append(("circle",removed_square[1]))
    return (detected, squares_labeled)

def split_test(img):
    # Chia test ra từng khu vực
    (detected, squares_labeled) = findContours(img)

    topdown = sorted(detected,key=lambda x: (x[1][1]))
    square_topdown = sorted(squares_labeled,key=lambda x: (x[1][1]))


    topdown_squares_check = [2,6,5,9,5] # Số ô vuông ở rìa mỗi khu vực

    areas = [[],[],[],[]]
    
    current_square_count = 0
    current_area = -1
    queue = []
    total_square_count = 0

    for index in range(0,len(topdown)):
        i = topdown[index]
        label = i[0]
        if label == "square":
            if (index > 0 and topdown[index-1][0] == "circle") and (index<len(topdown)-1 and topdown[index+1][0] == "circle"):
                areas[current_area].append(("circle",i[1]))
                square_topdown.pop(total_square_count)
            else:
                current_square_count += 1
                total_square_count += 1
        elif label == "circle":
            if current_square_count == topdown_squares_check[current_area+1]:
                current_area += 1
                current_square_count = 0
            if between(current_area,0,3):
                areas[current_area].append(i)


    #phieu = cv2.imread(img)
    #phieu = cv2.cvtColor(phieu,cv2.COLOR_BGR2RGB)
    #for x in square_topdown:
    #    cv2.rectangle(phieu,x[1],(255,0,0),-1)
    #plt.imshow(phieu)
    #plt.show()
#    current_square_count = 0
#    current_area = -1
#    queue = []
#    for i in topdown:
#        label = i[0]
#        if label == "square":
#            current_square_count += 1
#        elif label == "circle":
#            if current_square_count == topdown_squares_check[current_area+1]:
#                current_area += 1
#                current_square_count = 0
#            if between(current_area,0,3):
#                areas[current_area].append(i)


    # Thêm các ô vuông vào từng khu vực
    areas[0] += square_topdown[0:4]
    areas[1] += square_topdown[4:13]
    areas[2] += square_topdown[8:13]
    areas[3] += square_topdown[-5:]
    row4 = sortLeftRight(square_topdown[8:13])
    row5 = sortLeftRight(square_topdown[13:22])
    row6 = sortLeftRight(square_topdown[-5:])
    area_2_width = distance_x(row4[0][1],row4[1][1])
    area_3_width = distance_x(row6[0][1],row6[1][1])
    areas[2].append(row5[0])
    areas[3].append(row5[0])
    prev = 0
    for i in range(0,len(row5)):
        distance = distance_x(row5[i][1],row5[prev][1]) / area_2_width
        if abs(distance - 1) < 0.1:
            areas[2].append(row5[i])
            prev = i
    prev = 0
    for i in range(0,len(row5)):
        distance = distance_x(row5[i][1],row5[prev][1]) / area_3_width
        if abs(distance - 1) < 0.1:
            areas[3].append(row5[i])
            prev = i
    return areas

def process_meta(meta):
    # Xử lí meta từ trái sang phải
    meta = sortLeftRight(meta)
    results = []
    meta_splitted = split(meta)
    meta_result_labels = ['SBD','MDT']

    #print_split(meta_splitted)

    for i in range(0,min(len(meta_splitted),2)):
        region = meta_splitted[i]
        result_label = meta_result_labels[i]
        cur_part = 0
        for j in range(0,len(region)):
            label = region[j]
            if(label[0] == "circle" and j > 0):
                prev = region[j-1]
                distance = label[1][0] - prev[1][0]
                if(prev[0] == "square"):
                    cur_part += min(math.floor(distance/label[1][2]),1) 
                else:
                    cur_part += math.floor(distance/label[1][2])
                results.append((f'{result_label}{cur_part}',label[1]))

    return results

def process_content_1(content_1):
    results = []
    content_1 = sortLeftRight(content_1)
    content_1_split = split(content_1) # Chia phần trắc nghiệm thứ nhất thành 4 nhóm, từ trái sang phải

    for groupIndex in range(0,len(content_1_split)):
        questionGroup = content_1_split[groupIndex]
        #questionGroup = sortTopDown(questionGroup)
        questionGroup = sortDownTop(questionGroup) # Duyệt từ dưới lên trên để tăng tính chính xác,
                                                   # tránh lọt các chữ A,B,C,D bị phát hiện nhầm thành ô tròn
        head = questionGroup[0]
        if(head[0] == "circle"):
            prevQuestionGroup = sortTopDown(content_1_split[groupIndex-1])
            head = prevQuestionGroup[0]
        prev = head
        #cur_question = 0 if prev[0] == "square" else 1 
        cur_question = 10
        last = questionGroup[-1]
        #if prev[0] == "circle":
        #    results.append((f'1.{groupIndex*10 + cur_question}',prev[1]))
        for j in range(0,len(questionGroup)):
            label = questionGroup[j]
            if(label[0] == "circle"):
                distance = abs(label[1][1] - prev[1][1])
                distance_y_to_head = abs(label[1][1] - head[1][1])
                distance_y_to_last = abs(label[1][1] - last[1][1])
                distance_x_to_head = abs(label[1][0] - head[1][0])
                if distance/label[1][3] < 0.3 or distance_y_to_last/label[1][3] < 0.3 or distance_x_to_head/label[1][2] < 2:
                    continue
                if(prev[0] == "square"):
                    cur_question -= math.floor(distance/label[1][3])-2
                else:
                    cur_question -= math.floor(distance/label[1][3])
                if(cur_question < 1):
                    break
                results.append((f'1.{groupIndex*10 + cur_question}',label[1]))
            prev=questionGroup[j]
    return results

def process_content_2(content_2):
    results = []
    content_2 = sortLeftRight(content_2)
    content_2_split = split(content_2)
    #parts = ['a','b','c','d']
    parts = ['d','c','b','a']
    for groupIndex in range(0,len(content_2_split)-1):
        questionGroup = content_2_split[groupIndex]
        #questionGroup = sortTopDown(questionGroup)
        questionGroup  = sortDownTop(questionGroup)
        nextGroup = content_2_split[groupIndex+1]
        curGroupSquare_x = questionGroup[0][1][0]
        nextGroupSquare_x = nextGroup[0][1][0]
        cur_question = 0
        last = questionGroup[-1]
        for j in range(0,len(questionGroup)):
            label = questionGroup[j]
            if(label[0] == "circle" and j >0):
                prev = questionGroup[j-1]
                distance = abs(label[1][1] - prev[1][1])
                distance_to_last = abs(label[1][1] - last[1][1])
                if distance_to_last/label[1][3] < 0.3:
                    continue
                if(prev[0] == "square" and distance > label[1][3]):
                    cur_question += max(math.floor(distance/label[1][3]) - 1,1)
                else:
                    cur_question += round(distance/label[1][3])
                subGroup = 1 if abs(label[1][0] - curGroupSquare_x) < abs(label[1][0] - nextGroupSquare_x) else 2 
                if(cur_question <= 4):
                    results.append((f'2.{groupIndex*2 + subGroup}.{parts[cur_question-1]}',label[1]))
    return results

def process_content_3(content_3):
    results = []
    content_3 = sortLeftRight(content_3)
    content_3_split = split(content_3)
    for groupIndex in range(0,len(content_3_split)):
        questionGroup = content_3_split[groupIndex]
        questionGroup = sortLeftRight(questionGroup)
        cur_question = 0
        has_label = False
        for j in range(0,len(questionGroup)):
            label = questionGroup[j]
            if(label[0] == "circle" and j >0):
                prev = questionGroup[j-1]
                distance = (label[1][0] - prev[1][0])
                ratio = distance/label[1][2]
                if ratio > 0.5:
                    if(prev[0] == "square"):
                        cur_question += max(round(ratio) - 2,1)
                    else:
                        cur_question += max(math.floor(ratio),1)
                #results.append((f'3.{groupIndex+1}.{cur_question}',label[1]))
                if not has_label:
                    results.append((f'3.{groupIndex+1}',label[1]))
                    has_label = True
                else:
                    results.append(('',label[1]))
    return results

def process_test(img):
    areas = split_test(img)
    results = process_meta(areas[0]) + process_content_1(areas[1]) + process_content_2(areas[2]) + process_content_3(areas[3])
    return results

def grade_single_file(img_path, name, output,show=False,output_show=""):
    results = process_test(img_path)
    phieu_tno = cv2.imread(img_path)
    phieu_tno = cv2.cvtColor(phieu_tno, cv2.COLOR_BGR2RGB)
    (img_h,img_w,_) = phieu_tno.shape
    #print(f"width: {img_w}, height: {img_h}")

    with open("debug.txt",'a') as debug:
        debug.write(f'{name} {len(results)}\n')

    output.write(f'{name} ')
    for label in results:
        (x,y,w,h) = normalize(toYOLOv8(label[1]),img_w,img_h)
        #print_bounding_rect(toYOLOv8(label[1]))
        if(show):
            cv2.putText(phieu_tno,label[0],(label[1][0],label[1][1]),cv2.FONT_HERSHEY_PLAIN,1,(255,0,0),2)
            cv2.rectangle(phieu_tno,label[1],(0,255,0),1)
        output.write(label[0] + (' ' if label[0] != '' else ''))
        output.write(f'{round(x,6)},{round(y,6)},{round(w,6)},{round(h,6)} ')
    output.write('\n')
    if(show):
        if len(output_show) > 0:
            phieu_tno = cv2.cvtColor(phieu_tno,cv2.COLOR_RGB2BGR)
            cv2.imwrite(output_show,phieu_tno)
            #plt.imshow(phieu_tno)
            #plt.show()

def grade_directory(dir, output_file, export=False, export_dir=""):
    errors = 0
    done = 0
    with open(output_file,'w') as output:
        for (root,_,filenames) in os.walk(dir):
            total_files = len(filenames)
            for filename in filenames:
                #print(os.path.join(root,filename))
                try:
                    grade_single_file(os.path.join(root,filename),filename,output,export,os.path.join(export_dir,filename))
                except Exception as e:
                    print(f"error while trying to grade {filename}: {str(e)}")
                    errors +=1
                done +=1
                print(f"Done: {done}/{total_files}. Errors: {errors}",end='\r')
    print(f"There's total {errors} errors while grading directory")


# main

option = sys.argv[1]
match option:
    case "grade":
        target_type = sys.argv[2]
        target = sys.argv[3]
        output = sys.argv[4]
        if target_type == "file":
            with open(output,'w') as output_file:
                grade_single_file(target,target,output_file)
        elif target_type == "dir":
            grade_directory(target,output)
        else:
            print(f"Unknown target type: \'{target_type}\'")
    case "show":
        target_type = sys.argv[2]
        target = sys.argv[3]
        output = sys.argv[4]
        output_show = sys.argv[5]
        with open(output,'w') as output_file:
            if(target_type == "file"):
                grade_single_file(target,target,output_file,True,output_show)
            if(target_type == "dir"):
                grade_directory(target,output_file,True,output_show)








#if len(meta) == 9:
#    for i in range(0,6):
#        results.append((f"SBD{i+1}",meta[i]))
#    for i in range(6,9):
#        results.append((f"MDT{i-5}",meta[i]))
#else:
#    pass




#print(f'Found {len(circles)} filled circles and {len(squares)} filled squares')

#for s in circles:
#    cv2.rectangle(phieu_tno,cv2.boundingRect(s),(0,255,0),2)

#for s in squares:
#    cv2.rectangle(phieu_tno,cv2.boundingRect(s),(255,0,0),-1)







#plt.subplot(1,3,3)
#plt.imshow(phieu_tno,"gray")
#plt.title("phieu")
#plt.subplot(1,3,1)
#plt.imshow(thresh,"gray")
#plt.title("thresh")
#plt.subplot(1,3,2)
#plt.imshow(close,"gray")
#plt.title("close")

#plt.show()




